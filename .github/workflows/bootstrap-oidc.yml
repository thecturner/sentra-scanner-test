jobs:
  bootstrap_oidc:
    name: Create OIDC provider/role if missing, then disable this workflow
    runs-on: ubuntu-latest

    # We need to disable this workflow via the API AND write secrets/variables
    permissions:
      actions: write     # <-- required to create/update secrets & variables
      contents: read

    env:
      AWS_REGION: us-east-1
      OIDC_ROLE_NAME: ${{ vars.OIDC_ROLE_NAME || 'gha-oidc-sentra-scanner' }}
      WORKFLOW_FILE: bootstrap-oidc.yml

    steps:
      - name: Check out
        uses: actions/checkout@v4

      # ... (your existing guard, configure-aws, ensure awscli, check steps) ...

      - name: Setup Terraform
        if: steps.guard.outputs.no_creds != 'true' && (steps.check.outputs.provider_exists != 'true' || steps.check.outputs.role_exists != 'true')
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.9.5

      - name: Terraform init
        if: steps.guard.outputs.no_creds != 'true' && (steps.check.outputs.provider_exists != 'true' || steps.check.outputs.role_exists != 'true')
        run: terraform -chdir=infra/gha-oidc init -input=false

      - name: Terraform apply infra/gha-oidc
        if: steps.guard.outputs.no_creds != 'true' && (steps.check.outputs.provider_exists != 'true' || steps.check.outputs.role_exists != 'true')
        id: apply
        run: |
          set -euo pipefail
          terraform -chdir=infra/gha-oidc apply -auto-approve \
            -var='create_results_kms=false' \
            -var='results_kms_arn=""'

      # >>> NEW: discover the role ARN no matter if it existed or was just created
      - name: Discover OIDC role ARN
        if: steps.guard.outputs.no_creds != 'true'
        id: discover_role
        run: |
          set -euo pipefail
          ROLE="${{ env.OIDC_ROLE_NAME }}"
          ARN=$(aws iam get-role --role-name "$ROLE" --query 'Role.Arn' --output text)
          echo "role_arn=$ARN" >> "$GITHUB_OUTPUT"
          echo "Discovered role ARN: $ARN"

      # >>> NEW: store ARN as a repo secret and a repo variable
      - name: Save AWS_ROLE_ARN as repo secret and variable
        if: steps.guard.outputs.no_creds != 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          ROLE_ARN: ${{ steps.discover_role.outputs.role_arn }}
        run: |
          set -euo pipefail
          # Secret (masked in logs, good for compatibility with existing ci.yml)
          gh secret set AWS_ROLE_ARN --repo "${{ github.repository }}" --body "$ROLE_ARN"
          echo "Repo secret AWS_ROLE_ARN updated."

          # Variable (not secret; convenient for PRs and readability)
          # Create or update using REST (gh has no 'gh variable set' built-in yet on all runners)
          gh api \
            --method PATCH \
            -H "Accept: application/vnd.github+json" \
            "/repos/${{ github.repository }}/actions/variables/AWS_ROLE_ARN" \
            -f name="AWS_ROLE_ARN" -f value="$ROLE_ARN" \
          || gh api \
            --method POST \
            -H "Accept: application/vnd.github+json" \
            "/repos/${{ github.repository }}/actions/variables" \
            -f name="AWS_ROLE_ARN" -f value="$ROLE_ARN"
          echo "Repo variable AWS_ROLE_ARN set."

      # (keep your existing "Disable this workflow" step after these)
      - name: Disable this workflow
        if: steps.guard.outputs.no_creds != 'true' && (
              (steps.check.outputs.provider_exists == 'true' && steps.check.outputs.role_exists == 'true') ||
              always()
            )
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const workflow_id = process.env.WORKFLOW_FILE;
            core.info(`Disabling workflow ${workflow_id} for ${owner}/${repo}...`);
            try {
              await github.rest.actions.disableWorkflow({ owner, repo, workflow_id });
              core.info('Disabled. Re-enable from the Actions tab if needed.');
            } catch (e) {
              core.warning(`Could not disable workflow: ${e.message}`);
            }
