---
name: Bootstrap OIDC

on:
  push:
    branches: [dev, main]
    paths:
      - 'infra/gha-oidc/**'
      - '.github/workflows/bootstrap-oidc.yml'
  workflow_dispatch:

permissions:
  actions: write   # needed to create/update repo secrets/variables
  contents: read
  id-token: write  # not strictly required here, but harmless

jobs:
  bootstrap_oidc:
    name: Create OIDC provider/role if missing, then save ARN & (optionally) disable this workflow
    runs-on: ubuntu-latest

    env:
      AWS_REGION: us-east-1
      OIDC_ROLE_NAME: ${{ vars.OIDC_ROLE_NAME || 'gha-oidc-sentra-scanner' }}
      WORKFLOW_FILE: bootstrap-oidc.yml

    steps:
      - name: Check out
        uses: actions/checkout@v4

      # Guard: only run when temporary bootstrap credentials exist
      - name: "Guard: require bootstrap AWS creds or skip"
        id: guard
        shell: bash
        run: |
          if [[ -z "${{ secrets.BOOTSTRAP_AWS_ACCESS_KEY_ID }}" || -z "${{ secrets.BOOTSTRAP_AWS_SECRET_ACCESS_KEY }}" ]]; then
            echo "Bootstrap secrets are not set. Skipping bootstrap (expected after first run)."
            echo "no_creds=true" >> "$GITHUB_OUTPUT"
          else
            echo "no_creds=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Configure AWS credentials (temp access key)
        if: steps.guard.outputs.no_creds != 'true'
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id:     ${{ secrets.BOOTSTRAP_AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.BOOTSTRAP_AWS_SECRET_ACCESS_KEY }}
          aws-session-token:     ${{ secrets.BOOTSTRAP_AWS_SESSION_TOKEN }}
          aws-region:            ${{ env.AWS_REGION }}

      - name: Ensure AWS CLI present
        if: steps.guard.outputs.no_creds != 'true'
        run: aws --version || { sudo apt-get update && sudo apt-get install -y awscli; }

      # Detect whether provider/role already exist
      - name: Check for OIDC provider and role
        if: steps.guard.outputs.no_creds != 'true'
        id: check
        shell: bash
        run: |
          set -euo pipefail
          ROLE_NAME="${{ env.OIDC_ROLE_NAME }}"

          if aws iam list-open-id-connect-providers --query 'OpenIDConnectProviderList[].Arn' --output text | grep -q 'token.actions.githubusercontent.com'; then
            echo "provider_exists=true" >> "$GITHUB_OUTPUT"
          else
            echo "provider_exists=false" >> "$GITHUB_OUTPUT"
          fi

          if aws iam get-role --role-name "$ROLE_NAME" >/dev/null 2>&1; then
            echo "role_exists=true" >> "$GITHUB_OUTPUT"
          else
            echo "role_exists=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Setup Terraform
        if: steps.guard.outputs.no_creds != 'true' && (steps.check.outputs.provider_exists != 'true' || steps.check.outputs.role_exists != 'true')
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.9.5

      - name: Terraform init (infra/gha-oidc)
        if: steps.guard.outputs.no_creds != 'true' && (steps.check.outputs.provider_exists != 'true' || steps.check.outputs.role_exists != 'true')
        run: terraform -chdir=infra/gha-oidc init -input=false

      - name: Terraform apply (create provider/role if missing)
        if: steps.guard.outputs.no_creds != 'true' && (steps.check.outputs.provider_exists != 'true' || steps.check.outputs.role_exists != 'true')
        id: apply
        run: |
          set -euo pipefail
          terraform -chdir=infra/gha-oidc apply -auto-approve \
            -var='create_results_kms=false' \
            -var='results_kms_arn=""'

      # Discover the role ARN (works whether it existed or was just created)
      - name: Discover OIDC role ARN
        if: steps.guard.outputs.no_creds != 'true'
        id: discover_role
        run: |
          set -euo pipefail
          ROLE="${{ env.OIDC_ROLE_NAME }}"
          ARN=$(aws iam get-role --role-name "$ROLE" --query 'Role.Arn' --output text)
          echo "role_arn=$ARN" >> "$GITHUB_OUTPUT"
          echo "Discovered role ARN: $ARN"

      # Save ARN as secret + variable for other workflows
      - name: Save AWS_ROLE_ARN as repo secret and variable
        if: steps.guard.outputs.no_creds != 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          ROLE_ARN: ${{ steps.discover_role.outputs.role_arn }}
        run: |
          set -euo pipefail
          gh secret set AWS_ROLE_ARN --repo "${{ github.repository }}" --body "$ROLE_ARN"
          echo "Repo secret AWS_ROLE_ARN updated."
          gh api --method PATCH -H "Accept: application/vnd.github+json" \
            "/repos/${{ github.repository }}/actions/variables/AWS_ROLE_ARN" \
            -f name="AWS_ROLE_ARN" -f value="$ROLE_ARN" \
          || gh api --method POST -H "Accept: application/vnd.github+json" \
            "/repos/${{ github.repository }}/actions/variables" \
            -f name="AWS_ROLE_ARN" -f value="$ROLE_ARN"
          echo "Repo variable AWS_ROLE_ARN set."

      # Disable this workflow if (a) both already existed, or (b) we just applied successfully
      - name: Disable this workflow (when bootstrap complete)
        if: steps.guard.outputs.no_creds != 'true' && (
              (steps.check.outputs.provider_exists == 'true' && steps.check.outputs.role_exists == 'true') ||
              steps.apply.outcome == 'success'
            )
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const workflow_id = process.env.WORKFLOW_FILE;
            core.info(`Disabling workflow ${workflow_id} for ${owner}/${repo}...`);
            try {
              await github.rest.actions.disableWorkflow({ owner, repo, workflow_id });
              core.info('Disabled. Re-enable from the Actions tab if needed.');
            } catch (e) {
              core.warning(`Could not disable workflow: ${e.message}`);
            }
